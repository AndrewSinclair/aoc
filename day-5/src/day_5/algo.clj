(ns day-5.algo)

(defn three-vowels?
  [word]
  (let [vowels [\a \e \i \o \u]]
    (>=
      (count (filter #(.contains vowels %) word))
      3)))

(defn double-letters?
  [word]
  (loop [letter-a (first word)
        [letter-b & rest] (drop 1 word)]
    (if (nil? letter-b) false
      (or (= letter-a letter-b)
          (recur letter-b rest)))))

(defn restricted-letters?
  [word]
  (let [restricted-digraphs ["ab" "cd" "pq" "xy"]]
    (some #(.contains word %) restricted-digraphs)))

(defn nice-1?
  [word]
  ((every-pred
      three-vowels?
      double-letters?
      #(not (restricted-letters? %)))
    word))


(comment

  (defn update-accum
    "TODO"
    [pair-log]
    )

  (defn generate-pair-log
    "collect all pairs into a set of tuples like [pair num].
     Triples count as pairs. Four or more in a row should just return some dummy value indicating it."
    [word]
      (loop [[letter1 & rest] word
           accum #{}]
      (let [letter2 (first rest)
            letter3 (second rest)
            letter4 (nth rest 3)]
        ; FIXME what is the if-else-if-else notation again!?
        (if (= letter1 letter2 letter3 letter4) #{[(str letter1 letter2) 2]}
          (if (= letter1 letter2 letter3) (recur (drop 1 rest) (update-accum letter1 letter2 accum))
            (if (= letter1 letter2) (recur rest (update-accum letter1 letter2 accum))))))))

  (defn frequent-pair?
    "count the frequency of pairs generated by the pair log"
    [word]
      (some #(>= (second %) 2) (generate-pair-log word)))

  (defn nice-2?
    [word]
    ((every-pred
      frequent-pair?
      aba-pattern?)
    word))
)

(defn do-algo-1
  "find the total number of 'nice strings' on santa's naughty list"
  [strings]
  (count (filter nice-1? strings)))

(defn do-algo-2
  "find the total number of 'nice strings' on santa's naughty list"
  [strings]
  ;(count (filter nice-2? strings)))
)

